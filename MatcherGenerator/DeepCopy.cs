// DeepCopyGen/DeepCopyGenerator.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using static MatcherGenerator.Helpers;

namespace Matcher.Generator
{
    [Generator]
    public sealed class DeepCopyGenerator : ISourceGenerator
    {
        private const string AttributeSource = 
@"using System;

namespace Matcher
{
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
    public sealed class DeepCopyAttribute : Attribute
    { }
}
";

        public void Initialize(GeneratorInitializationContext context)
        {
            // add attribute
            context.RegisterForPostInitialization(pi =>
            {
                pi.AddSource("DeepCopyAttribute.g.cs", SourceText.From(AttributeSource, Encoding.UTF8));
            });

            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
                return;

            var compilation = context.Compilation;

            var deepCopyAttr = compilation.GetTypeByMetadataName("Matcher.DeepCopyAttribute");
            
            // get types
            var annotatedTypes = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

            foreach (var classDecl in receiver.CandidateClasses)
            {
                var model = compilation.GetSemanticModel(classDecl.SyntaxTree);
                var symbol = model.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
                if (symbol == null)
                    continue;
                bool hasDeepCopyAttr = symbol.GetAttributes().Any(a => (deepCopyAttr != null 
                     && SymbolEqualityComparer.Default.Equals(a.AttributeClass, deepCopyAttr))
                     || a.AttributeClass?.ToDisplayString() == "Matcher.DeepCopyAttribute"
                     || a.AttributeClass?.Name == "DeepCopyAttribute");
                if (hasDeepCopyAttr)
                    annotatedTypes.Add(symbol);
            }

            // generate code for each type
            foreach (var typeSymbol in annotatedTypes)
            {
                var source = GenerateForType(typeSymbol, annotatedTypes, context);
                var hintName = GetHintName(typeSymbol);

                context.AddSource(hintName, SourceText.From(source, Encoding.UTF8));
            }
        }

        static string GetHintName(INamedTypeSymbol typeSymbol)
        {
            // global::A.B.Outer+Inner -> A_B_Outer_Inner
            var full = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (full.StartsWith("global::", StringComparison.Ordinal))
                full = full.Substring("global::".Length);

            var safe = full
                .Replace('.', '_')
                .Replace('+', '_') // nested
                .Replace('<', '_')
                .Replace('>', '_')
                .Replace(',', '_');

            return $"{safe}.DeepCopy.g.cs";
        }
        static string GetExtensionClassName(INamedTypeSymbol typeSymbol)
        {
            var full = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (full.StartsWith("global::", StringComparison.Ordinal))
                full = full.Substring("global::".Length);

            var flat = full
                .Replace('.', '_')
                .Replace('+', '_')
                .Replace('<', '_')
                .Replace('>', '_')
                .Replace(',', '_');

            return $"{flat}DeepCopyCollectionExtensions";
        }
        private static string GenerateForType(
            INamedTypeSymbol typeSymbol,
            HashSet<INamedTypeSymbol> annotatedTypes,
            GeneratorExecutionContext context)
        {
            var ns = typeSymbol.ContainingNamespace?.ToDisplayString() ?? "";
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Linq;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Collections.ObjectModel;");

            if (!string.IsNullOrEmpty(ns))
            {
                sb.AppendLine($"namespace {ns}");
                sb.AppendLine("{");
            }
            var containingTypes = GetContainingTypes(typeSymbol);
            int openedTypes = 0;
            foreach (var ct in containingTypes)
            {
                if (!MatcherGenerator.Helpers.IsPartial(ct))
                    break;

                var acc = MatcherGenerator.Helpers.GetAccessibilityKeyword(ct.DeclaredAccessibility);
                var kind = ct.TypeKind == TypeKind.Struct ? "struct" : "class";
                sb.AppendLine($"{acc} partial {kind} {ct.Name}");
                sb.AppendLine("{");
                openedTypes++;
            }
            var typeName = typeSymbol.Name;
            // generate partial class
            var accessibility = MatcherGenerator.Helpers.GetAccessibilityKeyword(typeSymbol.DeclaredAccessibility);
            var typeKindKeyword = typeSymbol.TypeKind == TypeKind.Struct ? "struct" : "class";
            sb.AppendLine($"{accessibility} partial {typeKindKeyword} {typeName}");
            sb.AppendLine("{");
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Attempts to copy an object as deep as feasible.");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public {typeName} DeepCopy()");
            sb.AppendLine("    {");
            if (typeSymbol.TypeKind == TypeKind.Struct)
            {
                sb.AppendLine("        var copy = this;");
            }
            else
            {
                sb.AppendLine($"        var copy = ({typeName})this.MemberwiseClone();");
            }

            var members = GetInstanceMembers(typeSymbol);
            foreach (var m in members)
            {
                GenerateMemberCopy(sb, "copy", "this", m, annotatedTypes);
            }

            sb.AppendLine("        return copy;");
            sb.AppendLine("    }");
            sb.AppendLine("}"); // end class
            for (int i = 0; i < openedTypes; i++)
                sb.AppendLine("}");
            // List<T> and T[] extentions
            sb.AppendLine();
            var extName = GetExtensionClassName(typeSymbol);
            var fullT = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            sb.AppendLine($"public static class {extName}");
            sb.AppendLine("{");
            // List<T>
            sb.AppendLine($"    public static List<{fullT}> DeepCopy(this List<{fullT}> source)");
            sb.AppendLine("    {");
            sb.AppendLine("        if (source == null) return null;");
            sb.AppendLine($"        var result = new List<{fullT}>(source.Count);");
            sb.AppendLine("        for (int i = 0; i < source.Count; i++)");
            sb.AppendLine("        {");
            sb.AppendLine("            var item = source[i];");
            sb.AppendLine("            result.Add(item != null ? item.DeepCopy() : null);");
            sb.AppendLine("        }");
            sb.AppendLine("        return result;");
            sb.AppendLine("    }");

            // T[]
            sb.AppendLine($"    public static {fullT}[] DeepCopy(this {fullT}[] source)");
            sb.AppendLine("    {");
            sb.AppendLine("        if (source == null) return null;");
            sb.AppendLine($"        var result = new {fullT}[source.Length];");
            sb.AppendLine("        for (int i = 0; i < source.Length; i++)");
            sb.AppendLine("        {");
            sb.AppendLine("            var item = source[i];");
            sb.AppendLine("            result[i] = item != null ? item.DeepCopy() : null;");
            sb.AppendLine("        }");
            sb.AppendLine("        return result;");
            sb.AppendLine("    }");

            // Dictionary<TKey, T>
            sb.AppendLine($"    public static Dictionary<TKey, {fullT}> DeepCopy<TKey>(this Dictionary<TKey, {fullT}> source)");
            sb.AppendLine("    {");
            sb.AppendLine("        if (source == null) return null;");
            sb.AppendLine($"        var result = new Dictionary<TKey, {fullT}>(source.Count, source.Comparer);");
            sb.AppendLine("        foreach (var kv in source)");
            sb.AppendLine("        {");
            sb.AppendLine("            result[kv.Key] = kv.Value != null ? kv.Value.DeepCopy() : null;");
            sb.AppendLine("        }");
            sb.AppendLine("        return result;");
            sb.AppendLine("    }");

            sb.AppendLine($"    public static HashSet<{fullT}> DeepCopy(this HashSet<{fullT}> source)");
            sb.AppendLine("    {");
            sb.AppendLine("        if (source == null) return null;");
            sb.AppendLine($"        var result = new HashSet<{fullT}>(source.Comparer);");
            sb.AppendLine("        foreach (var item in source)");
            sb.AppendLine("            result.Add(item != null ? item.DeepCopy() : null);");
            sb.AppendLine("        return result;");
            sb.AppendLine("    }");

            // Queue<T>
            sb.AppendLine($"    public static Queue<{fullT}> DeepCopy(this Queue<{fullT}> source)");
            sb.AppendLine("    {");
            sb.AppendLine("        if (source == null) return null;");
            sb.AppendLine($"        var result = new Queue<{fullT}>(source.Count);");
            sb.AppendLine("        foreach (var item in source)");
            sb.AppendLine("            result.Enqueue(item != null ? item.DeepCopy() : null);");
            sb.AppendLine("        return result;");
            sb.AppendLine("    }");

            // Stack<T>
            sb.AppendLine($"    public static Stack<{fullT}> DeepCopy(this Stack<{fullT}> source)");
            sb.AppendLine("    {");
            sb.AppendLine("        if (source == null) return null;");
            sb.AppendLine($"        var result = new Stack<{fullT}>(source.Count);");
            sb.AppendLine("        foreach (var item in source.Reverse())"); // preserve order
            sb.AppendLine("            result.Push(item != null ? item.DeepCopy() : null);");
            sb.AppendLine("        return result;");
            sb.AppendLine("    }");

            // LinkedList<T>
            sb.AppendLine($"    public static LinkedList<{fullT}> DeepCopy(this LinkedList<{fullT}> source)");
            sb.AppendLine("    {");
            sb.AppendLine("        if (source == null) return null;");
            sb.AppendLine($"        var result = new LinkedList<{fullT}>();");
            sb.AppendLine("        foreach (var item in source)");
            sb.AppendLine("            result.AddLast(item != null ? item.DeepCopy() : null);");
            sb.AppendLine("        return result;");
            sb.AppendLine("    }");

            // SortedSet<T>
            sb.AppendLine($"    public static SortedSet<{fullT}> DeepCopy(this SortedSet<{fullT}> source)");
            sb.AppendLine("    {");
            sb.AppendLine("        if (source == null) return null;");
            sb.AppendLine($"        var result = new SortedSet<{fullT}>(source.Comparer);");
            sb.AppendLine("        foreach (var item in source)");
            sb.AppendLine("            result.Add(item != null ? item.DeepCopy() : null);");
            sb.AppendLine("        return result;");
            sb.AppendLine("    }");

            // ReadOnlyCollection<T>
            sb.AppendLine($"    public static ReadOnlyCollection<{fullT}> DeepCopy(this ReadOnlyCollection<{fullT}> source)");
            sb.AppendLine("    {");
            sb.AppendLine("        if (source == null) return null;");
            sb.AppendLine($"        var list = new List<{fullT}>(source.Count);");
            sb.AppendLine("        foreach (var item in source)");
            sb.AppendLine("            list.Add(item != null ? item.DeepCopy() : null);");
            sb.AppendLine("        return new ReadOnlyCollection<" + fullT + ">(list);");
            sb.AppendLine("    }");

            sb.AppendLine("}"); // end static class

            if (!string.IsNullOrEmpty(ns))
            {
                sb.AppendLine("}"); // end namespace
            }

            return sb.ToString();
        }
        
        
        private static void GenerateMemberCopy(
            StringBuilder sb,
            string copyVar,
            string sourceVar,
            ISymbol member,
            HashSet<INamedTypeSymbol> annotatedTypes)
        {
            ITypeSymbol type;
            string memberAccess;

            if (member is IFieldSymbol f)
            {
                type = f.Type;
                memberAccess = f.Name;
            }
            else if (member is IPropertySymbol p)
            {
                type = p.Type;
                memberAccess = p.Name;
            }
            else
            {
                return;
            }

            if (IsValueLike(type))
                return;

            // array
            if (type is IArrayTypeSymbol arrayType)
            {
                GenerateArrayCopy(sb, copyVar, sourceVar, memberAccess, arrayType, annotatedTypes);
                return;
            }
            // Named generic/regular types
            if (type is INamedTypeSymbol named)
            {
                var ns = named.ContainingNamespace?.ToDisplayString();
                if (ns == "System.Collections.Generic" && named.IsGenericType)
                {
                    var name = named.Name;
                    if (name == "List" || name == "IList" || name == "ICollection" || name == "IReadOnlyList" || name == "IEnumerable")
                    {
                        GenerateListLikeCopy(sb, copyVar, sourceVar, memberAccess, named.TypeArguments[0], annotatedTypes);
                        return;
                    }
                    if (name == "Dictionary" || name == "IDictionary" || name == "IReadOnlyDictionary")
                    {
                        GenerateDictionaryCopy(sb, copyVar, sourceVar, memberAccess, named.TypeArguments[0], named.TypeArguments[1], annotatedTypes);
                        return;
                    }
                    if (name == "HashSet")
                    {
                        GenerateHashSetCopy(sb, copyVar, sourceVar, memberAccess, named.TypeArguments[0], annotatedTypes);
                        return;
                    }
                    if (name == "Queue")
                    {
                        GenerateQueueCopy(sb, copyVar, sourceVar, memberAccess, named.TypeArguments[0], annotatedTypes);
                        return;
                    }
                    if (name == "Stack")
                    {
                        GenerateStackCopy(sb, copyVar, sourceVar, memberAccess, named.TypeArguments[0], annotatedTypes);
                        return;
                    }
                    if (name == "LinkedList")
                    {
                        GenerateLinkedListCopy(sb, copyVar, sourceVar, memberAccess, named.TypeArguments[0], annotatedTypes);
                        return;
                    }
                    if (name == "SortedSet")
                    {
                        GenerateSortedSetCopy(sb, copyVar, sourceVar, memberAccess, named.TypeArguments[0], annotatedTypes);
                        return;
                    }
                }
                if (ns == "System.Collections.ObjectModel" && named.Name == "ReadOnlyCollection" && named.IsGenericType)
                {
                    GenerateReadOnlyCollectionCopy(sb, copyVar, sourceVar, memberAccess, named.TypeArguments[0], annotatedTypes);
                    return;
                }
                // Reference type annotated
                if (named.TypeKind == TypeKind.Class || named.TypeKind == TypeKind.Struct)
                {
                    if (IsAnnotatedType(named, annotatedTypes))
                    {
                        sb.AppendLine($"        if ({sourceVar}.{memberAccess} != null)");
                        sb.AppendLine($"            {copyVar}.{memberAccess} = {sourceVar}.{memberAccess}.DeepCopy();");
                        elseBranchNull(sb, copyVar, memberAccess);
                    }
                    return;
                }

            }

        }
        private static void GenerateArrayCopy(
            StringBuilder sb,
            string copyVar,
            string sourceVar,
            string memberName,
            IArrayTypeSymbol arrayType,
            HashSet<INamedTypeSymbol> annotatedTypes)
        {
            var elemType = arrayType.ElementType;
            var elemTypeStr = elemType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            sb.AppendLine($"        if ({sourceVar}.{memberName} != null)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var src = {sourceVar}.{memberName};");
            sb.AppendLine($"            var dst = new {elemTypeStr}[src.Length];");
            if (IsValueLike(elemType))
            {
                sb.AppendLine("            Array.Copy(src, dst, src.Length);");
            }
            else if (IsAnnotatedType(elemType, annotatedTypes))
            {
                sb.AppendLine("            for (int i = 0; i < src.Length; i++)");
                sb.AppendLine("            {");
                sb.AppendLine("                var it = src[i];");
                sb.AppendLine("                dst[i] = it != null ? it.DeepCopy() : null;");
                sb.AppendLine("            }");
            }
            else
            {
                sb.AppendLine("            for (int i = 0; i < src.Length; i++)");
                sb.AppendLine("            {");
                sb.AppendLine("                dst[i] = src[i]; // copy reference");
                sb.AppendLine("            }");
            }
            sb.AppendLine($"            {copyVar}.{memberName} = dst;");
            sb.AppendLine("        }");
            elseBranchNull(sb, copyVar, memberName);
        }
        private static void GenerateListLikeCopy(
            StringBuilder sb,
            string copyVar,
            string sourceVar,
            string memberName,
            ITypeSymbol elemType,
            HashSet<INamedTypeSymbol> annotatedTypes)
        {
            var elem = elemType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            sb.AppendLine($"        if ({sourceVar}.{memberName} != null)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var src = {sourceVar}.{memberName};");
            sb.AppendLine($"            var dst = new System.Collections.Generic.List<{elem}>(src is ICollection<{elem}> c ? c.Count : 4);");

            if (IsValueLike(elemType))
            {
                sb.AppendLine("            foreach (var it in src) dst.Add(it);");
            }
            else if (IsAnnotatedType(elemType, annotatedTypes))
            {
                sb.AppendLine("            foreach (var it in src) dst.Add(it != null ? it.DeepCopy() : null);");
            }
            else
            {
                sb.AppendLine("            foreach (var it in src) dst.Add(it); // copy reference");
            }

            sb.AppendLine($"            {copyVar}.{memberName} = dst;");
            sb.AppendLine("        }");
            elseBranchNull(sb, copyVar, memberName);
        }
        private static void GenerateListCopy(
            StringBuilder sb,
            string copyVar,
            string sourceVar,
            string memberName,
            ITypeSymbol elemType)
        {
            sb.AppendLine($"        if ({sourceVar}.{memberName} != null)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var src = {sourceVar}.{memberName};");
            if (IsValueLike(elemType))
            {
                sb.AppendLine($"            var dst = new System.Collections.Generic.List<{elemType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>(src);");
                sb.AppendLine($"            {copyVar}.{memberName} = dst;");
            }
            else
            {
                sb.AppendLine($"            var dst = new System.Collections.Generic.List<{elemType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>(src.Count);");
                sb.AppendLine("            for (int i = 0; i < src.Count; i++)");
                sb.AppendLine("            {");
                sb.AppendLine("                dst.Add(src[i]); // copy reference");
                sb.AppendLine("            }");
                sb.AppendLine($"            {copyVar}.{memberName} = dst;");
            }
            sb.AppendLine("        }");
            elseBranchNull(sb, copyVar, memberName);
        }
        private static void GenerateDictionaryCopy(
            StringBuilder sb,
            string copyVar,
            string sourceVar,
            string memberName,
            ITypeSymbol keyType,
            ITypeSymbol valueType,
            HashSet<INamedTypeSymbol> annotatedTypes)
        {
            var k = keyType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var v = valueType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            sb.AppendLine($"        if ({sourceVar}.{memberName} != null)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var src = {sourceVar}.{memberName};");
            sb.AppendLine($"            var dst = new System.Collections.Generic.Dictionary<{k}, {v}>(src is System.Collections.Generic.Dictionary<{k}, {v}> d ? d.Count : 0, (src as System.Collections.Generic.IDictionary<{k},{v}>) is not null ? (src as System.Collections.Generic.Dictionary<{k},{v}>)?.Comparer : null);");
            if (IsValueLike(valueType))
            {
                sb.AppendLine("            foreach (var kv in src) dst[kv.Key] = kv.Value;");
            }
            else if (IsAnnotatedType(valueType, annotatedTypes))
            {
                sb.AppendLine("            foreach (var kv in src) dst[kv.Key] = kv.Value != null ? kv.Value.DeepCopy() : null;");
            }
            else
            {
                sb.AppendLine("            foreach (var kv in src) dst[kv.Key] = kv.Value; // copy reference");
            }
            sb.AppendLine($"            {copyVar}.{memberName} = dst;");
            sb.AppendLine("        }");
            elseBranchNull(sb, copyVar, memberName);
        }
        private static void GenerateHashSetCopy(
            StringBuilder sb,
            string copyVar,
            string sourceVar,
            string memberName,
            ITypeSymbol elemType,
            HashSet<INamedTypeSymbol> annotatedTypes)
        {
            var elem = elemType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            sb.AppendLine($"        if ({sourceVar}.{memberName} != null)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var src = {sourceVar}.{memberName};");
            sb.AppendLine($"            var dst = new System.Collections.Generic.HashSet<{elem}>( (src as System.Collections.Generic.HashSet<{elem}>)?.Comparer );");
            if (IsValueLike(elemType))
                sb.AppendLine("            foreach (var it in src) dst.Add(it);");
            else if (IsAnnotatedType(elemType, annotatedTypes))
                sb.AppendLine("            foreach (var it in src) dst.Add(it != null ? it.DeepCopy() : null);");
            else
                sb.AppendLine("            foreach (var it in src) dst.Add(it); // copy reference");
            sb.AppendLine($"            {copyVar}.{memberName} = dst;");
            sb.AppendLine("        }");
            elseBranchNull(sb, copyVar, memberName);
        }
        private static void GenerateQueueCopy(
            StringBuilder sb,
            string copyVar,
            string sourceVar,
            string memberName,
            ITypeSymbol elemType,
            HashSet<INamedTypeSymbol> annotatedTypes)
        {
            var elem = elemType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            sb.AppendLine($"        if ({sourceVar}.{memberName} != null)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var src = {sourceVar}.{memberName};");
            sb.AppendLine($"            var dst = new System.Collections.Generic.Queue<{elem}>(src is System.Collections.Generic.Queue<{elem}> q ? q.Count : 0);");
            if (IsValueLike(elemType))
                sb.AppendLine("            foreach (var it in src) dst.Enqueue(it);");
            else if (IsAnnotatedType(elemType, annotatedTypes))
                sb.AppendLine("            foreach (var it in src) dst.Enqueue(it != null ? it.DeepCopy() : null);");
            else
                sb.AppendLine("            foreach (var it in src) dst.Enqueue(it); // copy reference");
            sb.AppendLine($"            {copyVar}.{memberName} = dst;");
            sb.AppendLine("        }");
            elseBranchNull(sb, copyVar, memberName);
        }
        private static void GenerateStackCopy(
            StringBuilder sb,
            string copyVar,
            string sourceVar,
            string memberName,
            ITypeSymbol elemType,
            HashSet<INamedTypeSymbol> annotatedTypes)
        {
            var elem = elemType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            sb.AppendLine($"        if ({sourceVar}.{memberName} != null)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var src = {sourceVar}.{memberName};");
            sb.AppendLine($"            var dst = new System.Collections.Generic.Stack<{elem}>(src is System.Collections.Generic.Stack<{elem}> s ? s.Count : 0);");
            // push reversed enumeration
            if (IsValueLike(elemType))
                sb.AppendLine("            foreach (var it in src.Reverse()) dst.Push(it);");
            else if (IsAnnotatedType(elemType, annotatedTypes))
                sb.AppendLine("            foreach (var it in src.Reverse()) dst.Push(it != null ? it.DeepCopy() : null);");
            else
                sb.AppendLine("            foreach (var it in src.Reverse()) dst.Push(it); // copy reference");
            sb.AppendLine($"            {copyVar}.{memberName} = dst;");
            sb.AppendLine("        }");
            elseBranchNull(sb, copyVar, memberName);
        }
        private static void GenerateLinkedListCopy(
            StringBuilder sb,
            string copyVar,
            string sourceVar,
            string memberName,
            ITypeSymbol elemType,
            HashSet<INamedTypeSymbol> annotatedTypes)
        {
            var elem = elemType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            sb.AppendLine($"        if ({sourceVar}.{memberName} != null)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var src = {sourceVar}.{memberName};");
            sb.AppendLine($"            var dst = new System.Collections.Generic.LinkedList<{elem}>();");
            if (IsValueLike(elemType))
                sb.AppendLine("            foreach (var it in src) dst.AddLast(it);");
            else if (IsAnnotatedType(elemType, annotatedTypes))
                sb.AppendLine("            foreach (var it in src) dst.AddLast(it != null ? it.DeepCopy() : null);");
            else
                sb.AppendLine("            foreach (var it in src) dst.AddLast(it); // copy reference");
            sb.AppendLine($"            {copyVar}.{memberName} = dst;");
            sb.AppendLine("        }");
            elseBranchNull(sb, copyVar, memberName);
        }
        private static void GenerateSortedSetCopy(
            StringBuilder sb,
            string copyVar,
            string sourceVar,
            string memberName,
            ITypeSymbol elemType,
            HashSet<INamedTypeSymbol> annotatedTypes)
        {
            var elem = elemType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            sb.AppendLine($"        if ({sourceVar}.{memberName} != null)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var src = {sourceVar}.{memberName};");
            sb.AppendLine($"            var dst = new System.Collections.Generic.SortedSet<{elem}>((src as System.Collections.Generic.SortedSet<{elem}>)?.Comparer);");
            if (IsValueLike(elemType))
                sb.AppendLine("            foreach (var it in src) dst.Add(it);");
            else if (IsAnnotatedType(elemType, annotatedTypes))
                sb.AppendLine("            foreach (var it in src) dst.Add(it != null ? it.DeepCopy() : null);");
            else
                sb.AppendLine("            foreach (var it in src) dst.Add(it); // copy reference");
            sb.AppendLine($"            {copyVar}.{memberName} = dst;");
            sb.AppendLine("        }");
            elseBranchNull(sb, copyVar, memberName);
        }

        private static void GenerateReadOnlyCollectionCopy(
            StringBuilder sb,
            string copyVar,
            string sourceVar,
            string memberName,
            ITypeSymbol elemType,
            HashSet<INamedTypeSymbol> annotatedTypes)
        {
            var elem = elemType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            sb.AppendLine($"        if ({sourceVar}.{memberName} != null)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var src = {sourceVar}.{memberName};");
            sb.AppendLine($"            var list = new System.Collections.Generic.List<{elem}>(src.Count);");
            if (IsValueLike(elemType))
                sb.AppendLine("            foreach (var it in src) list.Add(it);");
            else if (IsAnnotatedType(elemType, annotatedTypes))
                sb.AppendLine("            foreach (var it in src) list.Add(it != null ? it.DeepCopy() : null);");
            else
                sb.AppendLine("            foreach (var it in src) list.Add(it); // copy reference");
            sb.AppendLine($"            {copyVar}.{memberName} = new System.Collections.ObjectModel.ReadOnlyCollection<{elem}>(list);");
            sb.AppendLine("        }");
            elseBranchNull(sb, copyVar, memberName);
        }

        private static void elseBranchNull(StringBuilder sb, string copyVar, string memberName)
        {
            sb.AppendLine("        else");
            sb.AppendLine("        {");
            sb.AppendLine($"            {copyVar}.{memberName} = null;");
            sb.AppendLine("        }");
        }

        private static bool IsValueLike(ITypeSymbol type)
        {
            // copy by value
            if (type.IsValueType)
                return true;

            // copy string by value
            if (type.SpecialType == SpecialType.System_String)
                return true;

            return false;
        }
        private static bool IsAnnotatedType(ITypeSymbol type, HashSet<INamedTypeSymbol> annotated)
        {
            if (type is INamedTypeSymbol n)
            {
                foreach (var t in annotated)
                {
                    if (SymbolEqualityComparer.Default.Equals(n, t) ||
                        (n.OriginalDefinition is not null && t.OriginalDefinition is not null &&
                         SymbolEqualityComparer.Default.Equals(n.OriginalDefinition, t.OriginalDefinition)))
                        return true;
                }
            }
            return false;
        }
        private sealed class SyntaxReceiver : ISyntaxReceiver
        {
            public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0)
                {
                    CandidateClasses.Add(cds);
                }
            }
        }
    }
}
